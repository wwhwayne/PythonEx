class Pow:
    """求幂"""

    def binary_pow(self, x, n):
        """
        binary 可以翻译为二分，也可以翻译为二进制，算法正好与二分幂一致，只是理解不一样
        比如当用于矩阵运算时，就不能理解为二进制运算

        2^10
        =2^0b1010
        =2^(2^4+2^2)
        =2^(2^4*1+2^3*0+2^2*1+2^1*0)
        =2*2^4*1+2^2^3*0+2*2^2*1+2*2*1*0

        可以看到二进制不断移动（对应 n >>= 1）
        次方不断乘（对应下文的 t *= t）
        而只有这一位为 1 的时候（对应 n & 1 == 1）才乘到结果上(r *= t)

        >>> Pow().binary_pow(2,5)
        32
        >>> Pow().binary_pow(2,10)
        1024
        """
        r = 1
        # 注意要取为 x 第一次乘就直接平方
        t = x
        while n:
            if n & 1 == 1:
                r *= t  # 只有二进制位为 1 的时候，才乘到结果上
            t *= t  # 不断乘，多一位是乘方的关系 x^(2^n+1)=x^(2^n*2)=x^(2^n+2^n)=x^(2n)*x^(2^n)
            n >>= 1  # 二进制右移
        return r


if __name__ == '__main__':
    import doctest

    doctest.testmod(verbose=True)
